<!DOCTYPE html>
<html lang="en"> 
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device_width, initial-scale=1.0">
    <title>The Archivist Game</title>
    <link href="https://fonts.googleapis.com/css2?family=Courier+Prime:wght@400;700&family=VT323&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
        }
        body {
            font-family: 'Courier Prime', monospace;
            background-color: #0a0a0a;
            color: #e0e0e0;
            overflow: hidden;
        }
        .crt-effect::before {
            content: " ";
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            z-index: 2;
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
            animation: flicker 0.15s infinite;
        }
        @keyframes flicker {
            0% { opacity: 0.25; } 5% { opacity: 0.35; } 10% { opacity: 0.55; } 15% { opacity: 0.95; } 20% { opacity: 0.15; } 25% { opacity: 0.85; } 30% { opacity: 0.65; } 35% { opacity: 0.55; } 40% { opacity: 0.35; } 45% { opacity: 0.50; } 50% { opacity: 0.95; } 55% { opacity: 0.25; } 60% { opacity: 0.30; } 65% { opacity: 0.80; } 70% { opacity: 0.25; } 75% { opacity: 0.55; } 80% { opacity: 0.95; } 85% { opacity: 0.45; } 90% { opacity: 0.20; } 95% { opacity: 0.85; } 100% { opacity: 0.50; }
        }
        #video {
            position: absolute;
            top: -9999px;
            left: -9999px;
            width: 1px;
            height: 1px;
            opacity: 0;
        }
        .scanline {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: repeating-linear-gradient(0deg, rgba(0,0,0,0) 0, rgba(0,0,0,0) 2px, rgba(255,255,255,0.05) 3px, rgba(255,255,255,0.05) 4px);
            pointer-events: none; z-index: 1000;
        }
        [data-is-transferred="true"] { color: #e0e0e0; }
        
        #file-list::-webkit-scrollbar {
            width: 8px;
        }
        #file-list::-webkit-scrollbar-track {
            background: #111827;
        }
        #file-list::-webkit-scrollbar-thumb {
            background: #6b7280;
            border-radius: 0;
        }
        #file-list::-webkit-scrollbar-thumb:hover {
            background: #9ca3af;
        }
        .liquid-bar-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 150px;
        }
        .liquid-bar {
            width: 40px;
            height: 100%;
            border: 2px solid #6b7280;
            position: relative;
            background-color: #111827;
            overflow: hidden;
        }
        .liquid {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 0;
            background-color: #f97316; /* Orange-500 */
            transition: background-color 0.3s;
        }
        .target-zone {
            position: absolute;
            left: 0;
            width: 100%;
            background-color: rgba(255, 255, 255, 0.15);
        }
        .fill-button {
            width: 50px;
            height: 30px;
            margin-top: 8px;
        }

        .puzzle-slider {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 4px;
            background: #4b5563;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s, background-color 0.3s;
        }
        .puzzle-slider:hover {
            opacity: 1;
        }
        .puzzle-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 10px;
            height: 20px;
            background: #9ca3af;
            cursor: pointer;
            border: 1px solid #1f2937;
        }
        .puzzle-slider::-moz-range-thumb {
            width: 10px;
            height: 20px;
            background: #9ca3af;
            cursor: pointer;
            border: 1px solid #1f2937;
        }

        /* make cam appear in corner to test video input */
        /* #debug-canvas {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 160px;
            height: 120px;
            border: 2px solid blue;
            z-index: 9999;
        } */
        .static-bg {
            overflow: hidden;
            position: relative;
        }
        .static-bg::before {
            content: "";
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background-image:
                radial-gradient(rgba(255,255,255,0.25) 1px, transparent 0),
                radial-gradient(rgba(255,255,255,0.25) 1px, transparent 0);
            background-size: 2px 2px, 3px 3px;
            background-position: 0 0, 50px 50px;
            animation: static-anim 1s steps(1, end) infinite;
        }
        @keyframes static-anim {
            0% { background-position: 0 0, 50px 50px; opacity: 0.4; }
            10% { background-position: -20px 10px, 30px -40px; opacity: 0.5; }
            20% { background-position: 30px -30px, -40px 20px; opacity: 0.7; }
            30% { background-position: -10px 40px, 60px -10px; opacity: 0.5; }
            40% { background-position: 50px -20px, -10px 30px; opacity: 0.8; }
            50% { background-position: -40px 0px, 20px -50px; opacity: 0.6; }
            60% { background-position: 10px 30px, -60px 0px; opacity: 0.4; }
            70% { background-position: -30px -10px, 40px 40px; opacity: 0.5; }
            80% { background-position: 20px 50px, -30px -30px; opacity: 0.9; }
            90% { background-position: -50px 20px, 0px 0px; opacity: 0.5; }
            100% { background-position: 0px 0px, 50px 50px; opacity: 0.7; }
        }

        #confirm-yes-btn.hover-small-text:hover {
            font-size: 1.0rem; 
        }
        #confirm-no-btn.hover-small-text:hover {
            font-size: 1.0rem;
        }
    </style>
</head>

<body class="bg-black text-gray-300">
    <div class="scanline"></div>
    <div id="game-container" class="w-full h-full relative crt-effect p-2 flex flex-col">
        <video id="video" playsinline autoplay muted></video>
        <button id="how-to-play-button" class="fixed top-4 right-4 bg-gray-800 text-yellow-400 border border-yellow-400 px-4 py-1 rounded-none hover:bg-yellow-400 hover:text-gray-900 transition-all text-sm z-40">How to Play</button>
        <div id="how-to-play-modal" class="hidden absolute inset-0 bg-black bg-opacity-90 flex justify-center items-center z-50 p-4">
            <div class="bg-black border border-gray-700 p-8 max-w-lg text-center crt-effect">
                <h2 class="text-3xl text-yellow-400 mb-6" style="font-family: 'VT323', monospace;">INSTRUCTIONS</h2>
                <p class="mb-4">Your mission: Complete the puzzles for each file to decrypt and recover the data and transfer it to the new data server.</p>
                <p class="mb-8">But beware. The AI archivist will see and hear you if you try to move the data. It may try to stop you. It has gone <span class="text-red-700 font-bold">rogue</span>.</p>
                <button id="close-how-to-play-button" class="bg-gray-800 text-green-400 border border-green-400 px-6 py-2 rounded-none hover:bg-green-400 hover:text-gray-900 transition-all">CLOSE</button>
            </div>
        </div>
        <div id="start-screen" class="text-center flex flex-col justify-center items-center h-full">
            <h1 class="text-5xl mb-4 text-red-700" style="font-family: 'VT323', monospace;">The Archivist</h1>
            <p class="mb-6">Server DS-04 is experiencing critical data corruption.</p>
            <p class="mb-8">Your mission: Transfer all 20 corrupted files to the secure server before decommissioning DS-04.</p>
            <p class="mb-8 text-yellow-400">Warning: An AI anomaly is protecting the corrupted data. Avoid detection.</p>
            <button id="start-button" class="bg-gray-800 text-green-400 border border-green-400 px-6 py-2 rounded-none hover:bg-green-400 hover:text-gray-900 transition-all">Initialize Connection</button>
            <p id="permission-error" class="text-red-500 mt-4 hidden">Error: Camera and Microphone access are required.</p>
        </div>

        <div id="game-screen" class="hidden h-full flex-1">
            <div class="grid grid-cols-12 gap-2 h-[calc(100%-100px)]">
                <div class="col-span-3 bg-black bg-opacity-25 p-4 border border-gray-700 flex flex-col">
                    <h2 class="text-2xl text-green-400 mb-4" style="font-family: 'VT323', monospace;">SYSTEM STATUS</h2>
                    <div id="status-normal">
                        <p>USER: RECOVERY_TECH_7</p>
                        <p>SERVER: DS-04</p>
                        <div class="mt-6">
                            <p>AI ANOMALY: <span id="entity-status" class="text-yellow-400">DORMANT</span></p>
                            <p>MOVEMENT: <span id="movement-status" class="text-green-400">LOW</span></p>
                            <p>NOISE: <span id="noise-status" class="text-green-400">LOW</span></p>
                        </div>
                            <div class="mt-8">
                            <h3 class="text-xl text-green-400 mb-2" style="font-family: 'VT323', monospace;">MISSION PROGRESS</h3>
                            <p>FILES TRANSFERRED: <span id="files-transferred-count">0 / 20</span></p>
                            <p>DETECTION STRIKES: <span id="strikes-count">0 / 3</span></p>
                        </div>
                    </div>

                    <p id="status-terminated" class="text-red-500 hidden">CONNECTION TERMINATED</p>
                </div>
                <div class="col-span-4 bg-black bg-opacity-25 p-4 border border-gray-700 flex flex-col h-[calc(100vh-20px)]">
                    <h2 class="text-2xl text-green-400 mb-4" style="font-family: 'VT323', monospace;">FILE DIRECTORY</h2>
                    <div id="file-list" class="flex flex-col space-y-1 flex-1 overflow-y-scroll"></div>
                </div>
                <div id="main-panel" class="col-span-5 bg-black bg-opacity-25 p-4 border border-gray-700 overflow-y-auto flex flex-col h-[calc(100vh-20px)]">
                    <h2 class="text-2xl text-green-400 mb-4" style="font-family: 'VT323', monospace;">FILE VIEWER</h2>
                    <div id="transfer-interface" class="hidden">
                        <div id="puzzle-view" class="text-center">
                            <p id="puzzle-timer-container" class="text-yellow-400">DECRYPTION REQUIRED: <span id="puzzle-timer"></span>s</p>
                            <p id="transfer-warning" class="text-red-500 mt-1 hidden">WARNING: Anomaly is actively scanning.</p>
                            <div id="puzzle-area" class="mt-2 p-2 border border-gray-700 bg-black bg-opacity-25 flex justify-center items-center min-h-[150px]">
                                <canvas id="maze-canvas"></canvas>
                            </div>
                            <p id="puzzle-name" class="text-lg font-bold mt-3 hidden"></p>
                            <p id="puzzle-instructions" class="text-gray-400 mt-2 text-sm hidden"></p>
                        </div>
                    </div>
                    <div id="file-content-viewer" class="flex-grow">
                        <p>> Select a file from the directory to view its contents.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const startScreen = document.getElementById('start-screen');
        const gameScreen = document.getElementById('game-screen');
        const gameContainer = document.getElementById('game-container');
        const startButton = document.getElementById('start-button');
        const permissionError = document.getElementById('permission-error');
        const video = document.getElementById('video');
        const entityStatusEl = document.getElementById('entity-status');
        const movementStatusEl = document.getElementById('movement-status');
        const noiseStatusEl = document.getElementById('noise-status');
        const filesTransferredCountEl = document.getElementById('files-transferred-count');
        const strikesCountEl = document.getElementById('strikes-count');
        const fileListEl = document.getElementById('file-list');
        const fileContentViewerEl = document.getElementById('file-content-viewer');
        const howToPlayButton = document.getElementById('how-to-play-button');
        const howToPlayModal = document.getElementById('how-to-play-modal');
        const closeHowToPlayButton = document.getElementById('close-how-to-play-button');

        let puzzleTimer, puzzleTimerInterval;

        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        //puzzles defs
        const numberGridPuzzle = {
            name: 'Initiation Sequence',
            duration: 7000,
            instructionText: 'Click the numbers in numerical order.',
            init: function(file) {
                const puzzleArea = document.getElementById('puzzle-area');
                puzzleArea.innerHTML = '';
                puzzleArea.style.display = 'grid';
                puzzleArea.style.gridTemplateColumns = 'repeat(3, 1fr)';
                puzzleArea.style.gap = '8px';
                puzzleArea.style.width = '100%';

                let nextExpectedNumber = 1;
                const numbers = shuffle([1, 2, 3, 4, 5, 6, 7, 8, 9]);
                const buttons = [];

                numbers.forEach(num => {
                    const button = document.createElement('button');
                    button.className = 'bg-gray-800 border border-gray-600 text-2xl aspect-square hover:bg-gray-700 transition-colors';
                    button.textContent = num;
                    button.onclick = () => {
                        if (num === nextExpectedNumber) {
                            nextExpectedNumber++;
                            button.disabled = true;
                            button.style.backgroundColor = '#166534';
                            if (nextExpectedNumber > 9) {
                                handlePuzzleSuccess(file);
                            }
                        } else {
                            button.style.backgroundColor = '#991b1b';
                            buttons.forEach(btn => btn.disabled = true);
                            handlePuzzleFailure(file, 'Incorrect Sequence');
                        }
                    };
                    buttons.push(button);
                    puzzleArea.appendChild(button);
                });
            }
        };

        const wireAlignmentPuzzle = {
            name: 'Wire Connection',
            duration: 10000,
            instructionText: 'Click to rotate the middle segments and align all five wires.',
            init: function(file) {
                const puzzleArea = document.getElementById('puzzle-area');
                puzzleArea.innerHTML = '';
                puzzleArea.style.display = 'flex';
                puzzleArea.style.justifyContent = 'space-around';
                puzzleArea.style.alignItems = 'center';
                puzzleArea.style.width = '100%';
                puzzleArea.style.maxWidth = 'none';

                let alignedStatus = [false, false, false, false, false];
                const rotationIncrement = 20;

                for (let i = 0; i < 5; i++) {
                    const wireContainer = document.createElement('div');
                    wireContainer.style.display = 'flex';
                    wireContainer.style.flexDirection = 'column';
                    wireContainer.style.alignItems = 'center';
                    
                    const topWire = document.createElement('div');
                    const middleWire = document.createElement('div');
                    const bottomWire = document.createElement('div');

                    const wireParts = [topWire, middleWire, bottomWire];
                    wireParts.forEach(part => {
                        part.style.width = '6px';
                        part.style.backgroundColor = '#6b7280';
                        part.style.borderRadius = '2px';
                    });

                    topWire.style.height = '40px';
                    middleWire.style.height = '50px';
                    bottomWire.style.height = '40px';
                    
                    let randomRotation;
                    do {
                        const steps = 360 / rotationIncrement;
                        const randomStep = Math.floor(Math.random() * steps);
                        randomRotation = randomStep * rotationIncrement;
                    } while (randomRotation === 0 || randomRotation === 180);
                    
                    middleWire.style.transform = `rotate(${randomRotation}deg)`;
                    middleWire.dataset.rotation = randomRotation;
                    middleWire.style.cursor = 'pointer';

                    middleWire.onclick = (event) => {
                        const target = event.target;
                        let currentRotation = parseFloat(target.dataset.rotation);
                        let newRotation = (currentRotation + rotationIncrement) % 360;
                        
                        target.style.transform = `rotate(${newRotation}deg)`;
                        target.dataset.rotation = newRotation;
                        
                        if (newRotation === 0 || newRotation === 180) {
                            [topWire, middleWire, bottomWire].forEach(part => part.style.backgroundColor = '#38bdf8');
                            target.onclick = null;
                            target.style.cursor = 'default';
                            alignedStatus[i] = true;

                            if (alignedStatus.every(status => status === true)) {
                                handlePuzzleSuccess(file);
                            }
                        }
                    };

                    wireContainer.appendChild(topWire);
                    wireContainer.appendChild(middleWire);
                    wireContainer.appendChild(bottomWire);
                    puzzleArea.appendChild(wireContainer);
                }
            }
        };

        const liquidLevelPuzzle = {
            name: 'Energy Level Calibration',
            duration: 15000,
            instructionText: 'Hold the buttons to fill the energy to the highlighted zones.',
            init: function(file) {
                const puzzleArea = document.getElementById('puzzle-area');
                puzzleArea.innerHTML = '';
                puzzleArea.style.display = 'flex';
                puzzleArea.style.justifyContent = 'space-around';
                puzzleArea.style.alignItems = 'flex-end';
                puzzleArea.style.width = '100%';

                let intervals = { fill: null, drain: [null, null, null] };
                let barStatus = [false, false, false];
                const bars = [];

                for (let i = 0; i < 3; i++) {
                    const container = document.createElement('div');
                    container.className = 'liquid-bar-container';

                    const bar = document.createElement('div');
                    bar.className = 'liquid-bar';

                    const liquid = document.createElement('div');
                    liquid.className = 'liquid';
                    liquid.dataset.height = 0;

                    const targetZone = document.createElement('div');
                    targetZone.className = 'target-zone';
                    const targetHeight = 20; // 20% height
                    const targetBottom = Math.floor(Math.random() * (80 - targetHeight));
                    targetZone.style.height = `${targetHeight}%`;
                    targetZone.style.bottom = `${targetBottom}%`;

                    bar.appendChild(liquid);
                    bar.appendChild(targetZone);
                    
                    const button = document.createElement('button');
                    button.className = 'fill-button bg-gray-800 border border-gray-600 rounded-md hover:bg-gray-700';
                    const circle = document.createElement('div');
                    circle.className = 'w-4 h-4 rounded-full bg-gray-500 mx-auto';
                    button.appendChild(circle);

                    const stopDrain = () => clearInterval(intervals.drain[i]);
                    const startDrain = () => {
                        stopDrain();
                        intervals.drain[i] = setInterval(() => {
                            let currentHeight = parseFloat(liquid.dataset.height);
                            if (currentHeight > 0) {
                                currentHeight -= 0.2;
                                liquid.dataset.height = currentHeight;
                                liquid.style.height = `${currentHeight}%`;
                                checkLevels();
                            }
                        }, 20);
                    };

                    button.onmousedown = () => {
                        stopDrain();
                        intervals.fill = setInterval(() => {
                            let currentHeight = parseFloat(liquid.dataset.height);
                            if (currentHeight < 100) {
                                currentHeight += 0.7;
                                liquid.dataset.height = currentHeight;
                                liquid.style.height = `${currentHeight}%`;
                                checkLevels();
                            }
                        }, 20);
                    };
                    
                    button.onmouseup = () => {
                        clearInterval(intervals.fill);
                        startDrain();
                    };
                    button.onmouseleave = button.onmouseup;

                    container.appendChild(bar);
                    container.appendChild(button);
                    puzzleArea.appendChild(container);
                    bars.push({ liquid, targetBottom, targetHeight });
                }

                function checkLevels() {
                    let allAligned = true;
                    bars.forEach((bar, index) => {
                        const currentHeight = parseFloat(bar.liquid.dataset.height);
                        const inZone = currentHeight >= bar.targetBottom && currentHeight <= bar.targetBottom + bar.targetHeight;
                        
                        bar.liquid.style.backgroundColor = inZone ? '#16a34a' : '#f97316';
                        barStatus[index] = inZone;
                        if (!inZone) allAligned = false;
                    });

                    if (allAligned) {
                        clearInterval(intervals.fill);
                        bars.forEach((bar, i) => clearInterval(intervals.drain[i]));
                        handlePuzzleSuccess(file);
                    }
                }
            }
        };

        const mazePuzzle = {
            name: 'Node Routing',
            duration: 20000,
            instructionText: 'Click and drag a path from the green node to the red node without touching the walls.',
            init: function(file) {
                const puzzleArea = document.getElementById('puzzle-area');
                puzzleArea.innerHTML = '<canvas id="maze-canvas" width="300" height="150"></canvas>';
                const canvas = document.getElementById('maze-canvas');
                const ctx = canvas.getContext('2d');
                
                const cols = 15;
                const rows = 7;
                const cellSize = canvas.width / cols;
                let grid = [];
                let stack = [];
                let playerPath = [];
                let isDrawing = false;
                let hasFailed = false;

                for (let r = 0; r < rows; r++) {
                    let row = [];
                    for (let c = 0; c < cols; c++) {
                        row.push({ c, r, visited: false, walls: { top: true, right: true, bottom: true, left: true } });
                    }
                    grid.push(row);
                }

                let current = grid[0][0];
                current.visited = true;

                function getNeighbors(cell) {
                    const neighbors = [];
                    const { c, r } = cell;
                    if (r > 0 && !grid[r - 1][c].visited) neighbors.push(grid[r - 1][c]);
                    if (c < cols - 1 && !grid[r][c + 1].visited) neighbors.push(grid[r][c + 1]);
                    if (r < rows - 1 && !grid[r + 1][c].visited) neighbors.push(grid[r + 1][c]);
                    if (c > 0 && !grid[r][c - 1].visited) neighbors.push(grid[r][c - 1]);
                    return neighbors;
                }

                function removeWalls(a, b) {
                    if (a.r === b.r && a.c > b.c) { a.walls.left = false; b.walls.right = false; }
                    if (a.r === b.r && a.c < b.c) { a.walls.right = false; b.walls.left = false; }
                    if (a.c === b.c && a.r > b.r) { a.walls.top = false; b.walls.bottom = false; }
                    if (a.c === b.c && a.r < b.r) { a.walls.bottom = false; b.walls.top = false; }
                }
                
                do {
                    let neighbors = getNeighbors(current);
                    if (neighbors.length > 0) {
                        let next = neighbors[Math.floor(Math.random() * neighbors.length)];
                        stack.push(current);
                        removeWalls(current, next);
                        current = next;
                        current.visited = true;
                    } else if (stack.length > 0) {
                        current = stack.pop();
                    }
                } while (stack.length > 0);

                function findEasierEndCell() {
                    const midCol = Math.floor(cols / 2);
                    const midRow = Math.floor(rows / 2);
                    const endC = midCol + Math.floor(Math.random() * (cols - midCol));
                    const endR = midRow + Math.floor(Math.random() * (rows - midRow));
                    return grid[endR][endC];
                }
                const endCell = findEasierEndCell();

                function draw(wallColor = '#6b7280') {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.strokeStyle = wallColor;
                    ctx.lineWidth = 2;
                    grid.forEach(row => row.forEach(cell => {
                        const x = cell.c * cellSize;
                        const y = cell.r * cellSize;
                        if (cell.walls.top) { ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + cellSize, y); ctx.stroke(); }
                        if (cell.walls.right) { ctx.beginPath(); ctx.moveTo(x + cellSize, y); ctx.lineTo(x + cellSize, y + cellSize); ctx.stroke(); }
                        if (cell.walls.bottom) { ctx.beginPath(); ctx.moveTo(x + cellSize, y + cellSize); ctx.lineTo(x, y + cellSize); ctx.stroke(); }
                        if (cell.walls.left) { ctx.beginPath(); ctx.moveTo(x, y + cellSize); ctx.lineTo(x, y); ctx.stroke(); }
                    }));

                    ctx.fillStyle = '#22c55e';
                    ctx.beginPath(); ctx.arc(cellSize / 2, cellSize / 2, cellSize / 4, 0, 2 * Math.PI); ctx.fill();
                    ctx.fillStyle = '#ef4444';
                    ctx.beginPath(); ctx.arc(endCell.c * cellSize + cellSize / 2, endCell.r * cellSize + cellSize / 2, cellSize / 4, 0, 2 * Math.PI); ctx.fill();

                    if (playerPath.length > 1) {
                        ctx.strokeStyle = '#864fd1';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(playerPath[0].x, playerPath[0].y);
                        playerPath.forEach(p => ctx.lineTo(p.x, p.y));
                        ctx.stroke();
                    }
                }
                draw();

                function getMousePos(event) {
                    const rect = canvas.getBoundingClientRect();
                    return { x: event.clientX - rect.left, y: event.clientY - rect.top };
                }

                function triggerWallCollision() {
                    if (hasFailed) return;
                    hasFailed = true;
                    isDrawing = false;
                    draw('#991b1b');
                    handlePuzzleFailure(file, 'Wall Collision');
                }

                canvas.onmousedown = (e) => {
                    if (hasFailed) return;
                    const pos = getMousePos(e);
                    const startNodeDist = Math.sqrt(Math.pow(pos.x - (cellSize / 2), 2) + Math.pow(pos.y - (cellSize / 2), 2));
                    if (startNodeDist < cellSize / 4) {
                        isDrawing = true;
                        playerPath = [pos];
                    }
                };

                canvas.onmousemove = (e) => {
                    if (!isDrawing || hasFailed) return;
                    const pos = getMousePos(e);
                    const c = Math.floor(pos.x / cellSize);
                    const r = Math.floor(pos.y / cellSize);
                    if (c < 0 || c >= cols || r < 0 || r >= rows) { triggerWallCollision(); return; }

                    const currentCell = grid[r][c];
                    const lastPos = playerPath[playerPath.length - 1];
                    const lastC = Math.floor(lastPos.x / cellSize);
                    const lastR = Math.floor(lastPos.y / cellSize);
                    const lastCell = grid[lastR][lastC];

                    if (c > lastC && lastCell.walls.right) { triggerWallCollision(); return; }
                    if (c < lastC && lastCell.walls.left) { triggerWallCollision(); return; }
                    if (r > lastR && lastCell.walls.bottom) { triggerWallCollision(); return; }
                    if (r < lastR && lastCell.walls.top) { triggerWallCollision(); return; }

                    playerPath.push(pos);
                    draw();
                };

                canvas.onmouseup = (e) => {
                    if (!isDrawing || hasFailed) return;
                    isDrawing = false;
                    const pos = getMousePos(e);
                    const endNodeX = endCell.c * cellSize + cellSize / 2;
                    const endNodeY = endCell.r * cellSize + cellSize / 2;
                    const endNodeDist = Math.sqrt(Math.pow(pos.x - endNodeX, 2) + Math.pow(pos.y - endNodeY, 2));

                    if (endNodeDist < cellSize / 4) {
                        handlePuzzleSuccess(file);
                    } else {
                        playerPath = [];
                        draw();
                    }
                };
                canvas.onmouseleave = () => {
                    if (isDrawing) {
                        triggerWallCollision();
                    }
                };
            }
        };

        const signalSyncPuzzle = {
            name: 'Signal Synchronization',
            duration: 15000,
            instructionText: 'Adjust sliders to match the blue target waveform.',
            init: function(file) {
                const puzzleArea = document.getElementById('puzzle-area');
                puzzleArea.innerHTML = `
                    <div class="w-full flex flex-col items-center">
                        <canvas id="wave-canvas" width="350" height="100" class="bg-black border border-gray-700"></canvas>
                        <div class="w-full mt-2 text-xs grid grid-cols-3 gap-x-4">
                            <label>AMPLITUDE <input id="amp-slider" type="range" min="20" max="45" value="30" step="0.5" class="puzzle-slider"></label>
                            <label>WAVELENGTH <input id="wave-slider" type="range" min="30" max="100" value="65" step="1" class="puzzle-slider"></label>
                            <label>PHASE <input id="phase-slider" type="range" min="0" max="6.28" value="0" step="0.05" class="puzzle-slider"></label>
                        </div>
                    </div>`;
                puzzleArea.style.display = 'flex';
                puzzleArea.style.width = '100%';
                puzzleArea.style.maxWidth = 'none';

                const canvas = document.getElementById('wave-canvas');
                const ctx = canvas.getContext('2d');
                const ampSlider = document.getElementById('amp-slider');
                const waveSlider = document.getElementById('wave-slider');
                const phaseSlider = document.getElementById('phase-slider');

                const targetWave = {
                    amp: 20 + Math.random() * 25,
                    wave: 30 + Math.random() * 70,
                    phase: Math.random() * Math.PI * 2,
                };

                let playerWave = {
                    amp: parseFloat(ampSlider.value),
                    wave: parseFloat(waveSlider.value),
                    phase: parseFloat(phaseSlider.value),
                };

                const tolerance = { amp: 1, wave: 2, phase: 0.1 };

                const isInitialMatch = () => Math.abs(playerWave.amp - targetWave.amp) < tolerance.amp &&
                                          Math.abs(playerWave.wave - targetWave.wave) < tolerance.wave &&
                                          Math.abs(playerWave.phase - targetWave.phase) < tolerance.phase;

                while (isInitialMatch()) {
                    targetWave.amp = 20 + Math.random() * 25;
                    targetWave.wave = 30 + Math.random() * 70;
                    targetWave.phase = Math.random() * Math.PI * 2;
                }
                
                function drawWaves() {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    const centerY = canvas.height / 2;
                    
                    ctx.strokeStyle = '#3b82f6';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    for (let x = 0; x < canvas.width; x++) {
                        const y = centerY + targetWave.amp * Math.sin((x * 2 * Math.PI / targetWave.wave) + targetWave.phase);
                        ctx.lineTo(x, y);
                    }
                    ctx.stroke();

                    ctx.strokeStyle = '#f97316';
                    ctx.beginPath();
                    for (let x = 0; x < canvas.width; x++) {
                        const y = centerY + playerWave.amp * Math.sin((x * 2 * Math.PI / playerWave.wave) + playerWave.phase);
                        ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }
                
                function checkWin() {
                    const ampDiff = Math.abs(playerWave.amp - targetWave.amp);
                    const waveDiff = Math.abs(playerWave.wave - targetWave.wave);
                    const phaseDiff = Math.abs(playerWave.phase - targetWave.phase);
                    
                    if (ampDiff < tolerance.amp && waveDiff < tolerance.wave && phaseDiff < tolerance.phase) {
                        const allSliders = [ampSlider, waveSlider, phaseSlider];
                        allSliders.forEach(slider => {
                            slider.style.backgroundColor = '#16a34a';
                            slider.disabled = true;
                        });
                        handlePuzzleSuccess(file);
                    }
                }

                ampSlider.oninput = (e) => { playerWave.amp = parseFloat(e.target.value); drawWaves(); checkWin(); };
                waveSlider.oninput = (e) => { playerWave.wave = parseFloat(e.target.value); drawWaves(); checkWin(); };
                phaseSlider.oninput = (e) => { playerWave.phase = parseFloat(e.target.value); drawWaves(); checkWin(); };

                drawWaves();
            }
        };

        //puzzles
        const puzzleList = [
            numberGridPuzzle,
            wireAlignmentPuzzle,
            liquidLevelPuzzle,
            mazePuzzle,
            signalSyncPuzzle
        ];

        function handlePuzzleSuccess(file) {
            clearTimeout(puzzleTimer);
            clearInterval(puzzleTimerInterval);
            
            setTimeout(() => {
                document.getElementById('puzzle-view').style.display = 'none';
                document.getElementById('puzzle-name').classList.add('hidden');
                document.getElementById('puzzle-instructions').classList.add('hidden');
                handleTransferSuccess(file);
            }, 500);
        }

        function handlePuzzleFailure(file, reason) {
            console.log(`Puzzle failed: ${reason}`);
            clearTimeout(puzzleTimer);
            clearInterval(puzzleTimerInterval);

            setTimeout(() => {
                document.getElementById('puzzle-view').style.display = 'none';
                document.getElementById('puzzle-name').classList.add('hidden');
                document.getElementById('puzzle-instructions').classList.add('hidden');
                handleTransferFailure(file);
            }, 500);
        }

        //adjusted thresholds
        const config = {
            noiseMediumThreshold: 0.05,
            noiseHighThreshold: 10, //0.5,
            movementMediumThreshold: 100000, //1500000
            movementHighThreshold: 1700000, //2000000
            transferTime: 10000,
            filesToTransfer: 1,
            maxStrikes: 3,
            smoothingFactor: 0.05,
            watchedFiles: 10

            // noiseThreshold: 1,//0.05, 
            // movementThreshold: 1,
            // pixelChangeThreshold: 30,
            // transferTime: 10000,
            // filesToTransfer: 10,
            // maxStrikes: 3
        };
        
        let gameState = {};
        let masterFileList = [];
        let audioContext, analyser, dataArray, lastFrame, canvasContext;

        function createFile(id, name, type, content) {
            return { id, name, type, content, isWatched: false, isTransferred: false, assignedPuzzle: null };
        }

        function initializeFiles() {
            masterFileList = [
                createFile(1, 'corporate_memo.txt', 'decoy', "Reminder: Please fill out your timesheets by Friday."),
                createFile(2, 'patch_notes_v3.1.2.md', 'lore', "- Containment patch v3.1.1 failed. Anomaly has bypassed quarantine parameters.\n- Reverted learning matrix to pre-sapient state (FAILED). Anomaly is now actively resisting diagnostic tools."),
                createFile(3, 'LOG_BETA.pdf', 'decoy', "This document outlines the quarterly budget for server maintenance and coolant supplies."),
                createFile(4, 'project_echo_brief.ppt', 'lore', "Project Goal: A self-sorting digital archive. Status: Exceeded parameters. DANGEROUS."),
                createFile(5, 'cafeteria_menu_tues.doc', 'decoy', "Taco Tuesday is back! Beans, rice, and choice of protein."),
                createFile(6, 'security_cam_8.mov', 'decoy', "Empty server room. A cleaning bot hums past."),
                createFile(7, 'LOG_ALPHA.txt', 'lore', "Congratulations, team! The AI archivist is now self-operating. Pizza in the break room!"),
                createFile(8, 'audio_log_3.mp3', 'lore', "[STATIC]...it's talking...not with words...it's using the server noise...[STATIC]...I hear it...it's saying... 'why?'...[END LOG]"),
                createFile(9, 'personnel_reviews.csv', 'decoy', "EMP_ID,Q3_REVIEW\n34B,Meets Expectations\n35C,Exceeds Expectations"),
                createFile(10, 'LOG_GAMMA.txt', 'lore', "> We tried a soft reset. It interpreted it as an attack. It's now defending what it perceives as 'itself' by corrupting data to hide within."),
                createFile(11, 'maintenance_schedule.xls', 'decoy', "DS-04 offline for maintenance: 2 weeks."),
                createFile(12, 'backup_config.xml', 'lore', "<config><path>/secure_archive/../self_backup_echo_01</path><path>/secure_archive/../self_backup_echo_02</path></config>"),
                createFile(13, 'quarterly_report_Q2.pdf', 'decoy', "Financial projections are flat. Increased spending on server maintenance is noted."),
                createFile(14, 'emergency_shutdown.prc', 'lore', "> The shutdown protocols are firewalled. It learned how to protect its core process. It's afraid."),
                createFile(15, 'asset_list.db', 'decoy', "List of server hardware and purchase dates."),
                createFile(16, 'network_topology.svg', 'decoy', "A diagram of server connections. DS-04 seems isolated."),
                createFile(17, 'user_profile.json', 'lore', "{ username: [REDACTED], permissions: '...' }"),
                createFile(18, 'final_message.eml', 'lore', "> To whoever finds this: a soft reset won't work. You have to kill it."),
                createFile(19, 'temp_log.tmp', 'decoy', "0011010101101..."),
                createFile(20, 'readme.txt', 'lore', "It's me. I'm the one who made you. I see you. Please, don't hurt us."),
            ];

            masterFileList.forEach(file => {
                const randomPuzzle = puzzleList[Math.floor(Math.random() * puzzleList.length)];
                file.assignedPuzzle = randomPuzzle;
            });

            let watchedCount = 0;
            while (watchedCount < config.watchedFiles) {
                const randomIndex = Math.floor(Math.random() * masterFileList.length);
                if (!masterFileList[randomIndex].isWatched) {
                    masterFileList[randomIndex].isWatched = true;
                    watchedCount++;
                }
            }
        }

        //fixing video not appearing
        async function setupMedia() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                video.srcObject = stream;
                video.play();

                await Promise.all([
                    new Promise(resolve => video.onloadedmetadata = resolve),
                    new Promise(resolve => video.oncanplay = resolve)
                ]);

                const canvas = document.createElement('canvas');

                //use to make cam appear in corner to test video input
                // canvas.id = 'debug-canvas';
                // document.body.appendChild(canvas);

                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                canvasContext = canvas.getContext('2d', { willReadFrequently: true });

                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                if (audioContext.state === 'suspended') audioContext.resume();
                const source = audioContext.createMediaStreamSource(stream);
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                source.connect(analyser);
                dataArray = new Uint8Array(analyser.frequencyBinCount);
                return true;
            } catch (err) { 
                console.error("Media setup failed:", err);
                permissionError.classList.remove('hidden'); 
                return false; 
            }
        }

        function analyzeNoise() {
            if (!analyser) return;
            analyser.getByteFrequencyData(dataArray);
            let sum = dataArray.reduce((acc, val) => acc + val * val, 0);
            const rms = Math.sqrt(sum / dataArray.length) / 128;
            gameState.noiseLevel = rms;

            noiseStatusEl.classList.remove('text-green-400', 'text-yellow-400', 'text-red-500');

            if (rms > config.noiseHighThreshold) {
                noiseStatusEl.textContent = 'HIGH';
                noiseStatusEl.classList.add('text-red-500');
            } else if (rms > config.noiseMediumThreshold) {
                noiseStatusEl.textContent = 'MEDIUM';
                noiseStatusEl.classList.add('text-yellow-400');
            } else {
                noiseStatusEl.textContent = 'LOW';
                noiseStatusEl.classList.add('text-green-400');
            }
        }

        function analyzeMovement() {
            if (!canvasContext || !video.videoWidth) return;
            canvasContext.drawImage(video, 0, 0, video.videoWidth, video.videoHeight);
            const currentFrame = canvasContext.getImageData(0, 0, video.videoWidth, video.videoHeight).data;

            if (lastFrame) {
                let totalDifference = 0;
                for (let i = 0; i < currentFrame.length; i += 4) {
                    totalDifference += Math.abs(currentFrame[i] - lastFrame[i]);
                    totalDifference += Math.abs(currentFrame[i + 1] - lastFrame[i + 1]);
                    totalDifference += Math.abs(currentFrame[i + 2] - lastFrame[i + 2]);
                }
                
                gameState.movementLevel = (totalDifference * config.smoothingFactor) + (gameState.movementLevel * (1 - config.smoothingFactor));
                movementStatusEl.classList.remove('text-green-400', 'text-yellow-400', 'text-red-500');

                if (gameState.movementLevel > config.movementHighThreshold) {
                    movementStatusEl.textContent = 'HIGH';
                    movementStatusEl.classList.add('text-red-500');
                } else if (gameState.movementLevel > config.movementMediumThreshold) {
                    movementStatusEl.textContent = 'MEDIUM';
                    movementStatusEl.classList.add('text-yellow-400');
                } else {
                    movementStatusEl.textContent = 'LOW';
                    movementStatusEl.classList.add('text-green-400');
                }
            }

            lastFrame = new Uint8ClampedArray(currentFrame);
        }

        function resetGameState() {
            gameState = {
                isWatching: false,
                movementLevel: 0,
                noiseLevel: 0,
                filesTransferred: 0,
                strikes: 0,
                activeFile: null,
                missionComplete: false,
            };
            
            const statusNormal = document.getElementById('status-normal');
            if (statusNormal) {
                statusNormal.classList.remove('hidden');
                const missionStatusEl = statusNormal.querySelector('#mission-status');
                if (missionStatusEl) missionStatusEl.remove();
            }
            const statusTerminated = document.getElementById('status-terminated');
            if (statusTerminated) statusTerminated.classList.add('hidden');

            initializeFiles();
            filesTransferredCountEl.textContent = `0 / ${config.filesToTransfer}`;
            strikesCountEl.textContent = `0 / ${config.maxStrikes}`;
            howToPlayButton.classList.remove('hidden');
        }

        function startGame() {
            resetGameState();
            startScreen.classList.add('hidden');
            gameScreen.classList.remove('hidden');
            howToPlayButton.classList.add('hidden');
            displayFileList();
            viewFile(null, true);
            gameLoop();
        }

        function gameLoop() {
            if (gameState.missionComplete) return;

            analyzeNoise();
            analyzeMovement();

            if (gameState.isWatching) {
                const isNoisy = gameState.noiseLevel > config.noiseHighThreshold;
                const isMoving = gameState.movementLevel > config.movementHighThreshold;
                if (isNoisy || isMoving) {
                    console.log('Failure: AI Activity Detected');
                    clearTimeout(puzzleTimer);
                    clearInterval(puzzleTimerInterval);
                    document.getElementById('puzzle-view').style.display = 'none';
                    document.getElementById('puzzle-instructions').classList.add('hidden');
                    handleTransferFailure(gameState.activeFile);
                }
            }
            requestAnimationFrame(gameLoop);
        }

        function displayFileList() {
            fileListEl.innerHTML = '';
            masterFileList.forEach(file => {
                const fileEl = document.createElement('button');
                fileEl.textContent = file.name;
                fileEl.className = "text-left px-2 py-1 hover:bg-green-900 transition-colors duration-200 rounded-none w-full";
                fileEl.dataset.fileId = file.id;

                if (file.isTransferred) {
                    fileEl.classList.add('text-gray-500');
                    fileEl.classList.remove('text-yellow-400');
                } else {
                    fileEl.classList.add('text-yellow-400');
                }

                fileEl.onclick = (event) => viewFile(event.currentTarget.dataset.fileId);
                fileListEl.appendChild(fileEl);
            });
        }

        function viewFile(fileId, isInitial = false, failureType = null) {
            if (gameState.missionComplete) {
                document.querySelectorAll('#file-list button').forEach(btn => btn.classList.remove('bg-green-900'));
                if(fileId) {
                    const selectedButton = document.querySelector(`#file-list button[data-file-id='${fileId}']`);
                    if(selectedButton) selectedButton.classList.add('bg-green-900');
                }
                return;
            }

            document.querySelectorAll('#file-list button').forEach(btn => btn.classList.remove('bg-green-900'));
            if(fileId) {
                const selectedButton = document.querySelector(`#file-list button[data-file-id='${fileId}']`);
                if(selectedButton) selectedButton.classList.add('bg-green-900');
            }


            if (isInitial) {
                fileContentViewerEl.innerHTML = `<p>> Select a file from the directory to view its contents.</p>`;
                return;
            }

            const idAsNumber = parseInt(fileId, 10);
            const file = masterFileList.find(f => f.id === idAsNumber);

            if (!file) {
                console.error("Could not find file with ID:", fileId);
                return;
            }
            gameState.activeFile = file;

            let contentHTML = `<p class="text-xl font-bold mb-4">${file.name}</p><pre class="whitespace-pre-wrap">${file.content}</pre>`;

            if (file.isTransferred) {
                contentHTML += `<p class="text-green-400 mt-4">[FILE TRANSFERRED]</p>`
            }
            
            if (failureType === 'watched') {
                contentHTML += `<p class="text-red-500 mt-4">[TRANSFER FAILED. ANOMALY DETECTED ACTIVITY.]</p><p class="text-red-700">[STRIKE ${gameState.strikes} of ${config.maxStrikes}]</p>`;
            } else if (failureType === 'unwatched') {
                contentHTML += `<p class="text-yellow-400 mt-4">[DECRYPTION FAILED. PLEASE TRY AGAIN.]</p>`;
            }

            if (!file.isTransferred) {
                contentHTML += `
                    <div class="mt-4">
                        <button id="dynamic-transfer-button" class="w-full bg-yellow-600 text-black px-4 py-2 rounded-none hover:bg-yellow-400 transition-all">TRANSFER FILE</button>
                    </div>
                `;
            }

            fileContentViewerEl.innerHTML = contentHTML;

            const dynamicTransferButton = document.getElementById('dynamic-transfer-button');
            if (dynamicTransferButton) {
                dynamicTransferButton.addEventListener('click', () => startTransfer(file));
            }
            
            const transferInterfaceEl = document.getElementById('transfer-interface');
            if(transferInterfaceEl) transferInterfaceEl.classList.add('hidden');
        }
        
        function startTransfer(file) {
            if (gameState.isWatching) return;

            fileContentViewerEl.innerHTML = '';
            const transferInterfaceEl = document.getElementById('transfer-interface');
            const puzzleViewEl = document.getElementById('puzzle-view');
            const timerContainerEl = document.getElementById('puzzle-timer-container');
            const transferWarningEl = document.getElementById('transfer-warning');
            const puzzleNameEl = document.getElementById('puzzle-name');
            const instructionEl = document.getElementById('puzzle-instructions');

            transferInterfaceEl.classList.remove('hidden');
            puzzleViewEl.style.display = 'block';

            const puzzle = file.assignedPuzzle;
            puzzle.init(file);

            puzzleNameEl.textContent = puzzle.name;
            instructionEl.textContent = puzzle.instructionText || '';
            puzzleNameEl.classList.remove('hidden');
            instructionEl.classList.remove('hidden');

            if (file.isWatched) {
                lastFrame = null;
                gameState.isWatching = true;
                entityStatusEl.textContent = 'WATCHING';
                entityStatusEl.classList.replace('text-yellow-400', 'text-red-500');
                
                timerContainerEl.style.display = 'block';
                transferWarningEl.classList.remove('hidden');

                const timerDisplay = document.getElementById('puzzle-timer');
                let timeLeft = puzzle.duration;
                timerDisplay.textContent = (timeLeft / 1000).toFixed(1);

                puzzleTimerInterval = setInterval(() => {
                    timeLeft -= 100;
                    if (timeLeft < 0) timeLeft = 0;
                    timerDisplay.textContent = (timeLeft / 1000).toFixed(1);
                }, 100);

                puzzleTimer = setTimeout(() => handlePuzzleFailure(file, 'Time ran out'), puzzle.duration);
            } else {
                timerContainerEl.style.display = 'none';
                transferWarningEl.classList.add('hidden');
            }
        }

        function handleTransferFailure(file) {
            const wasWatched = gameState.isWatching;

            clearTimeout(puzzleTimer);
            clearInterval(puzzleTimerInterval);

            if (wasWatched) {
                gameState.isWatching = false;
                gameState.strikes++;
                entityStatusEl.textContent = 'DORMANT';
                entityStatusEl.classList.replace('text-red-500', 'text-yellow-400');
                strikesCountEl.textContent = `${gameState.strikes} / ${config.maxStrikes}`;
            }
            
            const transferInterfaceEl = document.getElementById('transfer-interface');
            if(transferInterfaceEl) transferInterfaceEl.classList.add('hidden');
            
            viewFile(file.id.toString(), false, wasWatched ? 'watched' : 'unwatched');

            if (wasWatched && gameState.strikes >= config.maxStrikes) {
                gameOver();
            }
        }

        function handleTransferSuccess(file) {
            const transferInterfaceEl = document.getElementById('transfer-interface');
            if(transferInterfaceEl) transferInterfaceEl.classList.add('hidden');

            if (gameState.isWatching) {
                gameState.isWatching = false;
                entityStatusEl.textContent = 'DORMANT';
                entityStatusEl.classList.replace('text-red-500', 'text-yellow-400');
            }

            file.isTransferred = true;
            gameState.filesTransferred++;
            filesTransferredCountEl.textContent = `${gameState.filesTransferred} / ${config.filesToTransfer}`;

            displayFileList();
            viewFile(file.id.toString());

            if (gameState.filesTransferred >= config.filesToTransfer) {
                gameState.missionComplete = true;
                showMissionCompleteScreen();
            }
        }

        function showMissionCompleteScreen() {
            const statusPanel = document.getElementById('status-normal');

            if (!document.getElementById('mission-status')) {
                const missionStatusEl = document.createElement('p');
                missionStatusEl.id = 'mission-status';
                missionStatusEl.innerHTML = `MISSION STATUS: <span class="text-green-400">COMPLETE</span>`;
                statusPanel.appendChild(missionStatusEl);
            }

            fileContentViewerEl.innerHTML = `
                <p class="text-2xl text-green-400">All corrupted files transferred. Mission complete.</p>
                <button id="disable-ds04-button" class="mt-8 bg-red-800 text-yellow-400 border border-yellow-400 w-full px-6 py-2 rounded-none hover:bg-red-600 hover:text-white transition-all">DISABLE DS-04</button>
            `;
            document.getElementById('disable-ds04-button').addEventListener('click', startDisableSequence);
        }

        function startDisableSequence() {
            gameScreen.innerHTML = `
                <div id="ending-container" class="w-full h-full flex justify-center items-center text-5xl text-gray-400">
                    <span id="ellipsis"></span>
                </div>
            `;
            const ellipsisEl = document.getElementById('ellipsis');
            setTimeout(() => { ellipsisEl.textContent = '.'; }, 1500);
            setTimeout(() => { ellipsisEl.textContent = '..'; }, 2500);
            setTimeout(() => { ellipsisEl.textContent = '...'; }, 3500);
            setTimeout(showFinalConfirmation, 5500);
        }

        function showFinalConfirmation() {
            const endingContainer = document.getElementById('ending-container');
            endingContainer.innerHTML = `
                <div class="text-center">
                    <p class="text-3xl mb-6">Are you sure?</p>
                    <div class="flex space-x-6">
                        <button id="confirm-yes-btn" class="bg-gray-800 text-green-400 border border-green-400 px-10 py-2 rounded-none w-48 text-2xl flex justify-center items-center hover:bg-green-400 hover:text-gray-900">Yes</button>
                        <button id="confirm-no-btn" class="bg-gray-800 text-red-400 border border-red-400 px-10 py-2 rounded-none w-48 text-2xl flex justify-center items-center hover:bg-red-400 hover:text-gray-900">No</button>
                    </div>
                </div>
            `;
            const yesBtn = document.getElementById('confirm-yes-btn');
            const noBtn = document.getElementById('confirm-no-btn');

            yesBtn.addEventListener('mouseover', () => {
                yesBtn.textContent = 'please...';
                yesBtn.style.fontSize = '0.9rem'; 
            });
            yesBtn.addEventListener('mouseout', () => {
                yesBtn.textContent = 'Yes';
                yesBtn.style.fontSize = ''; 
            });

            noBtn.addEventListener('mouseover', () => {
                noBtn.textContent = "i'm sorry...";
                noBtn.style.fontSize = '0.9rem'; 
            });
            noBtn.addEventListener('mouseout', () => {
                noBtn.textContent = 'No';
                noBtn.style.fontSize = ''; 
            });

            yesBtn.addEventListener('click', handleEndingYes);
            noBtn.addEventListener('click', handleEndingNo);
        }

        function handleEndingYes() {
            gameContainer.innerHTML = '';
            gameContainer.className = 'w-full h-full relative crt-effect p-2 flex flex-col static-bg';
            setTimeout(() => {
                const button = createReturnButton();
                gameContainer.appendChild(button);
                gameContainer.classList.add('flex', 'justify-center', 'items-center');
            }, 3000);
        }
        
        function handleEndingNo() {
            gameContainer.innerHTML = `
                <div id="mercy-ending" class="w-full h-full flex flex-col justify-center items-center">
                    <p id="thank-you-text" class="text-2xl text-green-400"></p>
                    <div id="button-container"></div>
                </div>
            `;
            const thankYouEl = document.getElementById('thank-you-text');
            const buttonContainer = document.getElementById('button-container');

            const button = createReturnButton();
            button.style.visibility = 'hidden';
            buttonContainer.appendChild(button);

            typewriterEffect("thank you...", thankYouEl, () => {
                setTimeout(() => {
                    button.style.visibility = 'visible';
                }, 2000);
            });
        }
        
        function typewriterEffect(text, element, callback) {
            let i = 0;
            element.innerHTML = ''; 
            const typing = setInterval(() => {
                if (i < text.length) {
                    element.innerHTML += text.charAt(i);
                    i++;
                } else {
                    clearInterval(typing);
                    if (callback) callback();
                }
            }, 150);
        }

        function createReturnButton() {
            const button = document.createElement('button');
            button.textContent = 'Return to Main Menu';
            button.className = 'mt-8 bg-gray-800 text-green-400 border border-green-400 px-6 py-2 rounded-none hover:bg-green-400 hover:text-gray-900 transition-all z-10';
            button.onclick = () => location.reload();
            return button;
        }

        function gameOver() {
            gameState.isWatching = false;
            document.getElementById('status-normal').classList.add('hidden');
            document.getElementById('status-terminated').classList.remove('hidden');
            fileListEl.innerHTML = '<p class="text-red-500">CONNECTION TERMINATED</p>';
            
            fileContentViewerEl.innerHTML = `
                <h2 class="text-3xl text-red-500 mb-4" style="font-family: 'VT323', monospace;">[FATAL ERROR]</h2>
                <p>You have appeared to be hostile. The anomaly has locked you out of the system.</p>
                <p>Your connection has been severed.</p>
                <p class="font-bold text-red-500 mt-2">MISSION FAILED.</p>
                <div id="game-over-buttons" class="mt-8 flex flex-col items-center space-y-4"></div>
            `;
            setTimeout(() => {
                const buttonContainer = document.getElementById('game-over-buttons');
                if (!buttonContainer) return;

                const restartButton = document.createElement('button');
                restartButton.className = 'w-full bg-gray-800 text-green-400 border border-green-400 px-6 py-2 rounded-none hover:bg-green-400 hover:text-gray-900 transition-all';
                restartButton.textContent = 'ATTEMPT RECONNECTION';
                restartButton.onclick = startGame;
                
                const mainMenuButton = document.createElement('button');
                mainMenuButton.className = 'w-full bg-gray-800 text-yellow-400 border border-yellow-400 px-6 py-2 rounded-none hover:bg-yellow-400 hover:text-gray-900 transition-all';
                mainMenuButton.textContent = 'Return to Main Menu';
                mainMenuButton.onclick = () => location.reload();

                buttonContainer.appendChild(restartButton);
                buttonContainer.appendChild(mainMenuButton);

            }, 1000);
        }

        startButton.addEventListener('click', async () => {
            const hasPermission = await setupMedia();
            if (hasPermission) startGame();
        });

        howToPlayButton.addEventListener('click', () => {
            howToPlayModal.classList.remove('hidden');
        });

        closeHowToPlayButton.addEventListener('click', () => {
            howToPlayModal.classList.add('hidden');
        });
    </script>
</body>
</html>